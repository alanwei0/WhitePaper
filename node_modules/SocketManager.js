var util = require('util');
var EventEmitter = require('events').EventEmitter;

var ROOM_SIZE = 2;

var SocketManager = function SocketManager(){
    this.io;
    this.eventManager;
};

util.inherits(SocketManager, EventEmitter);

SocketManager.prototype.init = function(server , eventManager){
    var self = this;
    this.io = require('socket.io').listen(server);
    // this.io.set('heartbeat timeout' , 10);
    // this.io.set('heartbeat interval' , 4);
    this.eventManager = eventManager;
    this.on();


    eventManager.on( eventManager.load_room_id_res , function(data , socket){
        console.log('SocketManager get load_room_id_res');
        socket.emit('load_room_id_res' , data);
    });

    eventManager.on( eventManager.create_room_res , function(data , socket){
        console.log('SocketManager get create_room_res');
        var success = data[0];  
        if(success){
            var roomId = data[1][0];
            var user = data[1][1];
            socket.join(roomId);
            self.bindUserToSocket(socket , roomId , user);
        }
        socket.emit('create_room_res' , data);
    });

    //this event emits to the parter
    eventManager.on( eventManager.join_room_res , function(data , socket){
        console.log('SocketManager get join_room_res');
        var success = data[0];
       
        if(success){
            var roomId = data[1][0];
            var user = data[1][1];
            var url = data[1][2];
            socket.canvas_url = url;
            socket.join(roomId);
            self.bindUserToSocket(socket , roomId , user);
            data[1][1] = self.getClientsName(roomId);
            self.broadcast(roomId , socket , 'partner_into_room_req' , user);
        }
        socket.emit('join_room_res' , data);
        

    });

};

SocketManager.prototype.on = function(){
    var self = this;
    var eventManager = this.eventManager;
    this.io.sockets.on('connection', function (socket) {
        console.log('a new socket connected');

        //when user lose the connection
        socket.on('disconnect', function(){
            if(self.io.sockets.clients(socket.roomId).length <= 1){
                //do nothing
            }else{
                self.broadcast(socket.roomId , socket , 'partner_disconnect' , socket.user);
            } 
        });

        //tested
        socket.on('load_room_id_req',function(data){//data = ''
            console.log('get load_room_id_req');
            eventManager.emit(eventManager.load_room_id_req, '' , socket);
        });

        //tested
        socket.on('create_room_req',function(data){ // data = [roomId , password , user]
            eventManager.emit(eventManager.create_room_req , data , socket);
        });

        //
        socket.on('join_room_req' , function(data){// data = [roomId , password , user]
            console.log('get join_room_req');
            var full = self.roomIsFull(data[0]);
            if(full[0]){ 
                socket.emit('join_room_res' , full);
                return null;
            }
            eventManager.emit(eventManager.join_room_req , data , socket);
        });

        socket.on('leave_room_req' , function(data){
            if(self.io.sockets.clients(socket.roomId).length < 1){
                
            }else{
                self.broadcast(socket.roomId, socket , 'partner_leave_room' , socket.user);
            }
            socket.leave(socket.roomId);
        });

        socket.on('canvas_req' , function(data){
            self.broadcast(socket.roomId , socket , 'canvas_res' , data);
        });

        //upload canvas
        socket.on('upload_canvas' , function(data){
            if(!socket.canvas) socket.canvas = '';
            var arr = data.match(/^#end#(.*)$/);
            if(arr){
                var url = socket.canvas + arr[1];
                eventManager.emit(eventManager.save_canvas , [socket.roomId , url] , socket);
            }else{
                socket.canvas += data;
            }
            
        });

        socket.on('chat_req' , function(data){
            self.broadcast(socket.roomId , socket , 'chat_res' , data);
        });

        socket.on('get_canvas_res' , function(data){
            eventManager.emit(eventManager.save_canvas , [socket.roomId , data] , socket);
            self.broadcast(socket.roomId , socket , 'recover_canvas_res' , data);
        });

        socket.on('recover_canvas_req' , function(data){
            var users = self.getClientsName(socket.roomId);
            if(users instanceof Array && users.length === 2){
                self.broadcast(socket.roomId , socket , 'get_canvas_req' , '');
            }else{
                socket.emit('recover_canvas_res' , socket.canvas_url);
                socket.canvas_url = null;
            }
        });

        socket.on('recover_canvas_over_req' , function(data){
            self.broadcast(socket.roomId , socket , 'recover_canvas_over_res' , '');
        });
    });
};

/**
* Broadcast data to client sockets
*
*@param {String} roomId id of the room
*@param {Socket} except socket without broadcast
*@param {Any} data 
*@return null
*/
SocketManager.prototype.broadcast = function(roomId , except , event , data){
    console.log('come to broadcast!!!!!!!!!!');
    var socket_list = this.io.sockets.clients(roomId);
    var i;
    for(i in socket_list){
        if(socket_list[i] !== except){
            console.log('begin to broadcast!!!!!!!!!!');
            socket_list[i].emit(event , data); 
        }       
    }
};

//we bind room to socket because socket will leave all rooms when it's disconnected, so we can't broadcast to partners
SocketManager.prototype.bindUserToSocket = function(socket , roomId , user){
    socket.user = user;
    socket.roomId = roomId;
};

SocketManager.prototype.roomIsFull = function(roomId){
    var i;
    var rooms = this.io.sockets.manager.rooms;
    for(i in rooms){
        if(i === ('/'+roomId)){
            var sockets = this.io.sockets.clients(roomId);
            if(sockets.length >= ROOM_SIZE){
                return [1 , 'room is full'];
            }else{
                return [0 , 'room is not full'];
            }
        } 
    }
    return [0, ''];

};

SocketManager.prototype.getClientsName = function(roomId){
    var sockets = this.io.sockets.clients(roomId);
    var names = [];
    var i;
    for(i in sockets){
        names.push(sockets[i].user);
    }
    return names;
};



module.exports = SocketManager;